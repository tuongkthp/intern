# Một số các file và thư mục chính của Nginx

/etc/nginx/: là thư mục cấu hình mặc định chính cho Nginx server.

/etc/nginx/nginx.conf là file để thêm vào các cấu hình mặc định được sử dụng bởi Nginx service. File cấu hình này được thiết lập để cấu hình chung cho mọi thứ như: worker process, tuning, logging, loading dynamic modules, và tham khảo cho các file cấu hình Nginx khác. Mặc định ban đầu thì file này bao gồm các top-level http block, chỉ dẫn tới tất cả các file cấu hình khác trong một thư mục được chỉ định.

/etc/nginx/conf.d/ đây chính là thư mục chứa file cấu hình HTTP server mặc định. Các file trong thư mục này có đuôi là .conf đều được bao gồm trong top-level http block trong file /etc/nginx/nginx.conf.

/var/log/nginx/ là thư mục mặc định để lưu trữ log cho Nginx. Thường sẽ có ít nhất hai file access.log và error.log. access log bao gồm các entry của mỗi request Nginx servers. error log file bao gồm các events lỗi và debug information nếu debug module được enabled.

# Nginx command
Show the Nginx help menu

    nginx -h

Show the Nginx version

    nginx -v

Show the Nginx version, build information và các đối số cấu hình để show ra các modules built trong Nginx binary.

    nginx -V

Test the Nginx configuration

    nginx -t 

Sử dụng flag `-s` để gửi một tiến hiệu tới Nginx master process, ví dụ: stop, quit, reload và reopen. Ví dụ stop signal sẽ ngắt kết nối tới tiền trình Nginx process ngay lập tức.

    nginx -s signal 

# Một số các thao tác hữu ích để quản trị

Test configuration

    nginx -t -c /etc/nginx/nginx.conf

Starting daemon:

    /usr/sbin/nginx -g 'daemon on; master_process on;'

    service nginx start
    systemctl start nginx

    /usr/local/etc/rc.d/nginx start

    # You can also start NGINX from start-stop-daemon script:
    /sbin/start-stop-daemon --quiet --start --exec /usr/sbin/nginx --background --retry QUIT/5 --pidfile /run/nginx.pid

Stopping daemon:

    /usr/sbin/nginx -s quit     # graceful shutdown (waiting for the worker processes to finish serving current requests)
    /usr/sbin/nginx -s stop     # fast shutdown (kill connections immediately)

    service nginx stop
    systemctl stop nginx

    /usr/local/etc/rc.d/nginx stop

    # You can also stop NGINX from start-stop-daemon script:
    /sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid

Reloading daemon:

    /usr/sbin/nginx -g 'daemon on; master_process on;' -s reload

    service nginx reload
    systemctl reload nginx

    kill -HUP $(cat /var/run/nginx.pid)
    kill -HUP $(pgrep -f "nginx: master")

Restarting daemon:

    service nginx restart
    systemctl restart nginx

    /usr/local/etc/rc.d/nginx restart

# Configuration syntax
Nginx sửa dụng micro programming language trong file cấu hình. Ngôn ngữ này được thiết kế chịu ảnh hưởng chủ yếu từ Perl và Bourne Shell. Nhưng cấu hình của NGINX có cấu trúc đơn giản và dễ nhìn hơn.

- Nginx configuration files không hỗ trợ các thành phần blocks, chỉ cho phép các dòng comments bắt đầu bằng ký từ `#`.

- Các dòng bao gồm các `directives` phải được kết thúc bằng dấu chấm phẩy (`;`) nếu không sẽ có lỗi khi load cấu hình.

Variables, Strings, Quotes: Các biến sẽ được bắt đầu với `$`. Một vài các modules đưa ra các variables có thể được sử dụng khi thiết lập các directives.

- Để chỉ ra các giá trị cho các variable bạn nên sử dụng `set` directive:

        set $var "value";

Một số điều thú vị về variables:

- Hầu hết các variables trong Nginx chỉ tồn tại runtime chứ không phải trong suốt thời gian cấu hình.

- Phạm vi của các biến có thể được phủ rộng trên toàn bộ cấu hình.

- Gán các variables xảy ra khi request đang thực sự được phục vụ

- Các variables có cùng thời gian tồn tại với các requests tương ứng.

- Mỗi một yêu cầu sẽ có các phiên bản riêng của các vùng chứa của biến đó (khác với vùng chứa của các value)

- Các request sẽ không gây trở ngại lẫn nhau ngay cả khi chúng đang tham chiếu tới cùng một biến có cùng tên.

- Các yêu cầu gán chỉ được thực hiện trong các request truy cập vào các location,

Strings có thể được nhập vào mà không cần bọc bởi cặp dấu nháy (`"`) nếu chúng không chứa các khoảng trống (space), dấu chấm phẩy, hoặc dấu ngoặc nhọn, sau đó chúng cần được thoát bằng backslashes hoặc kèm theo dấu nháy đơn hoặc đôi.

Các dấu nháy sẽ được yêu cầu cho các giá trị chứa space và `/` hoặc một số các ký tự đặc biệt, nếu không Nginx sẽ không thể phân biệt được chúng. Hoặc có thể dùng `\` trước các ký tự đặc biệt, ví dụ hai cách viết dưới đây là tương đương:

    add_header X-Header "nginx web server;";

    # Hoặc 

    add_header X-Header nginx\ web\ server\;;

### Directives, Blocks, and Contexts

Các tùy chọn cấu hình sẽ được gọi là `directives`. Có 4 loại `directives`

- standard directive - one value per context:

        worker_connections 512;

- array directive - multiple values per context:

        error_log /var/log/nginx/localhost/localhost-error.log warn;

- action directive - something which does not just configure:

        rewrite ^(.*)$ /msie/$1 break;

- `try_files` directive:

        try_files $uri $uri/ /test/index.html;

Directives được tổ chức thành các nhóm gọi là blocks hoặc contexts. Nói chung thì context là một block directive. Chúng được tổ chức tương tự với cấu trúc dạng cây, được định nghĩa bởi các cặp dấu ngoặc nhọn (`{}`). Các cặp dấu ngoặc nhọn sẽ biểu một cấu hình context mới.

Như một rule thông thường, nếu một directive trong nhiều phạm vi chồng lên nhau, một declaration trong một context rộng hơn sẽ được chuyển cho context con làm giá trị mặc định. Children contexts có thể sẽ bị ghi đè các giá trị mặc định. Các directives được đặt trong file cấu hình bên ngoài các context sẽ được coi là global/main context.

Directives có thể chỉ được sử dụng trong contexts được thiết kế cho chúng. Nginx sẽ bị lỗi khi đọc file cấu hình với các directives được tuyên bố trong contexts sai.

Các contexts có thể bị xếp lớp chồng lấn lên nhau (level of inheritance). Cấu trúc sẽ tương tự như sau:

```sh
Global/Main Context
        |
        |
        +-----» Events Context
        |
        |
        +-----» HTTP Context
        |          |
        |          |
        |          +-----» Server Context
        |          |          |
        |          |          |
        |          |          +-----» Location Context
        |          |
        |          |
        |          +-----» Upstream Context
        |
        |
        +-----» Mail Context
```

Một số các context phổ biến:

- global

- events

- http

- server

- location

- upstream

Nginx cũng cung cấp một số các context khác (ví dụ: được sử dụng cho việc mapping) như:

- map

- geo

- types

- if

- limit_except

- map

Dưới đây là mô hình cấu trúc tổng quan về các context

![1](img/1.png)

Nginx sẽ bắt đầu tìm kiếm từ http block, sau đó thông qua một hoặc nhiều server blocks, theo sau là các location blocks.

### External files
Directive `include` có thể được đặt bên trong bất cứ một context nào để thực hiện các điều kiện đi kèm. Nó đính kèm thêm một file khác hoặc nhiều file khớp với specified mask:

    include /etc/nginx/proxy.conf;

### Measurement units
Các ký hiều về sizes:
- `k` hoặc `K`: Kilobytes

- `m` hoặc `M`: Megabytes

- `g` hoặc `G`: Gigabytes

```sh
client_max_body_size 2M;
```

Time intervals:
- ms: Milliseconds

- s: Seconds (default, without a suffix)

- m: Minutes

- h: Hours

- d: Days

- w: Weeks

- M: Months (30 days)

- y: Years (365 days)

```sh
proxy_read_timeout 20s;
```

### HTTP Keep-Alive connections
Mô hình ban đầu của HTTP và mô hình mặc định trong HTTP/1.0 là các short-lived kết nối. Mỗi HTTP requests được kết thúc ngay sau mỗi connection của chúng, điều này nghĩa là một TCP handshake xảy ra trước mọi HTTP request, và chúng nỗi tiếp nhau. Client tạo ra một TCP connection mới cho mỗi giao dịch (các kết nỗi sẽ bị ngắt sau khi giao dịch hoàn tất)

HTTP Keep-Alive connection hoặc persistent connection sử dụng một TCP connection đơn để gửi và nhận nhiều HTTP requests/responses (Keep Alive làm việc giữ các requests), không mở các kết nối mới cho mỗi cặp request/response.

Cơ chế này giữ TCP connection giữa các client và server sau khi một giao dịch HTTP được hoàn thành. Đều này rất quan trọng bởi Nginx cần đóng các kết nối theo thời gian, thậm chí ngay cả khi nếu NGINX cấu hình cho phép keep-alive-timeouts là vô cùng (không timeout) và một cho phép một lượng lớn các requests trên một connection để trả về kết quả lỗi hoặc thành công.

![2](img/2.png)

Persistent connection model giữ các kết nối được mở giữa các requests liên tiếp, giảm thời gian cần thiết để mở các kết nối mới. HTTP pipelining model sẽ thêm một bước nữa, bằng việc gửi một số các requests mà không đợi phản hồi, giảm nhiều độ trễ trong network.

![3](img/3.png)

Một ví dụ dưới đây:
```sh
 Client                        Proxy                         Server
   |                             |                              |
   +- Keep-Alive: timeout=600 -->|                              |
   |  Connection: Keep-Alive     |                              |
   |                             +- Keep-Alive: timeout=1200 -->|
   |                             |  Connection: Keep-Alive      |
   |                             |                              |
   |                             |<-- Keep-Alive: timeout=300 --+
   |                             |    Connection: Keep-Alive    |
   |<- Keep-Alive: timeout=120  -+                              |
   |    Connection: Keep-Alive   |                              |
   |                             |                              |
```

Tất cả các kết nối đều được thỏa thuận độc lập. Client gửi một request tới và cho bết timeout là 600s (100 min), nhưng proxy lại yêu cầu giảm chỉ còn 120s (2min). Trên link giữa proxy và server, proxy request một timeout là 1200s và server muốn giảm chỉ còn 300s. như vậy ta có thể thấy timeout policies được duy trì bởi proxy khác nhau cho mỗi kết nối. Mỗi một hop sẽ kết nối độc lập.

Keepalive connections làm giảm chi phí, đặc biệt là khi SSL/TLS được sử dụng nhưng chúng cũng có nhiều nhược điểm; thậm chí cả khi rảnh rỗi chúng cũng tiêu tốn tài nguyên của server và chạy dưới nền tải rát nặng, DoS attack có thể được thực hiện. Trong các trường hợp như vậy nên sử dụng non-persistent connections, đóng kết nối ngay khi không hoạt động, có thể sẽ có hiệu năng tốt hơn.

Nginx đóng tất cả các keepalive connections khi worker_connections đạt tới giới hạn.

Nginx cung cấp hai layers để kích hoạt Keep-alive:
- Client layer
    + Số lượng tối đa xác keepalive requests cho một client có thể thực hiện trên một kết nối nhất định, ví dụ: 256 request thành công trong một keepalive connection:
    ```sh
        # Default: 100
    keepalive_requests  256;
    ```

    + Server sẽ đóng các kết nối sau thời gian này. Một con số cao hơn có thể được yêu cầu khi có một số lượng lớn các traffic để đảm bảo không khởi tạo các kết nối TCP thường xuyên. Nếu thiết lập quá thấp, bạn sẽ không tận dụng được keepalive trên hầu hết các requests của bạn làm chậm client:
    ```sh
     # Default: 75s
    keepalive_timeout   10s;
    ```

- Upstream layer

    + Số lượng các kết nối keepalive chở vẫn luôn giữ các worker process luôn mở. Các tham số connections thiết lập con số lớn nhất cho các idle keepalive connections tới các upstream server, cái mà luôn được để trong bộ nhớ đệm (cache) của mỗi worker process (khi vượt quá con số này các kết nối ít được sử dụng gần đây nhất sẽ bị đóng lại)

    ```sh
     # Default: disable
    keepalive         32;
    ```

Mặc định Nginx chỉ sử dụng HTTP/1.0 để nói chuyện với upsteam server. Để giữ các TCP connection alive thì cả upstream section và origin server đều nên được cấu hình để không hoàn thành kết nối.

> Chú ý: keepalive là một tính năng của HTTP 1.1, Nginx sử dụng 1.0 mặc định cho mỗi upstream servers.

Mắc định các kết nối sẽ không được sử dụng lại bởi keepalive trong upstream section có nghĩa là không giữ lại (mỗi lần bạn có thể thấy số lượng TCP stream tăng lên cho mỗi request tới server gốc)

HTTP keepalive đảm bảo Nginx Upstream server giúp giảm độ trễ và cải thiện hiệu suất và nó giảm khả năng Nginx chạy hết các ephemeral ports.

> Các tham số kết nối nên được thiết lập một con số nhỏ vừa đủ để đảm bảo các upstream server xử lý các process mới đến trong các connection thật tốt.

Cập nhật cấu hình upstream để sử dụng keepalive:
```sh
upstream bk_x8080 {
  ...
  keepalive         16;

}
```

Và kích hoạt HTTP/1.1 protocol trong tất cả các upstream requests:
```sh
server {

  ...

  location / {

    # Default is HTTP/1, keepalive is only enabled in HTTP/1.1:
    proxy_http_version  1.1;
    # Remove the Connection header if the client sends it,
    # it could be "close" to close a keepalive connection:
    proxy_set_header    Connection "";

    proxy_pass          http://bk_x8080;

  }

}

...

}
```

# Serving Static Content
Nginx có các server blocks (tương tự với các virtual hosts trong Apache) sử dụng `Listen` and `server_name` để chuyển hướng, bind tới các TCP sockets.

Ghi đè cấu hình HTTP server trong file `/etc/nginx/conf.d/default.conf` với cấu hình nginx tương tự như sau:
```sh
server {
  listen 80 default_server;
  server_name www.example.com;

  location / {
  root /usr/share/nginx/html;
  # alias /usr/share/nginx/html;
  index index.html index.htm;
  }
}
```

Cấu hình này phục vụ static files qua HTTP trên port 80 từ thư mục `/usr/share/nginx/html/`.

Dòng đầu tiên là cấu hình định nghĩa một server block mới, để xác định nội dung mới cho Nginx lắng nghe.

Dòng thứ 2 chỉ ra port để Nginx lắng nghe là port 80, tham số `default_server` được Nginx sử dụng như context mặc định cho port 80.

`server_name` xác định hostname hoặc tên mà request sẽ được chuyển hướng đến máy chủ này. Nếu cấu hình vẫn chưa định nghĩa `default_server`, Nginx sẽ chuyển hướng request tới server này chỉ khi nếu HTTP host header matched với giá trị được cung cấp trong giá trị của `server_name`.

Location block định nghĩa cấu hình dựa trên đường dẫn trong URL. Đường dẫn hoặc một phần của URL sau domain, được biết đến như URI.









































